

AI-Native Planning Approaches
1. Structured Files + LLM Orchestration (Best Fit for Your Stack)
Given your PowerShell factory, MCP integration plans, and event-logging architecture, I'd recommend a git-native, LLM-orchestrated planning system:
yaml# .plans/epic-001-bootstrap.yaml
epic:
  id: epic-001
  title: "Phase 0 - Repository Bootstrap"
  status: in_progress
  ai_context: |
    This epic establishes the deterministic factory baseline.
    All subsequent work depends on this foundation.
  
  stories:
    - id: story-001-001
      title: "Initialize repo structure"
      status: completed
      acceptance_criteria:
        - "Folders exist: /docs, /config, /scripts, /.runs, /worktrees, /.gate"
        - "Git remote bound to GitHub"
        - "Baseline commit pushed"
      
      ai_generated_tasks:
        - task: "Create skeleton directories"
          status: done
          implementation: "Phase0_Bootstrap.ps1:L95-L115"
          event_log: ".runs/20250116T120000Z-abc123/events.jsonl"
        
        - task: "Configure git remote"
          status: done
          autonomous_execution: true
          validation_check: "git remote -v | grep origin"
Why this works for AI development:

LLM can read and update the planning files directly
Event correlation: Links plans to your existing .runs/ event logs
Autonomous task generation: AI can break down stories into tasks
Validation hooks: Machine-readable acceptance criteria for AI agents to verify

2. MCP Server for Planning (Extends Your Existing Architecture)
Since you're already planning MCP integration, add a fourth MCP server for project management:
MCP Triad → Tetrad:

Microsoft Learn Docs (reference)
PowerShell AI Shell (execution)
GitHub (code review/CI)
Planning MCP (orchestration/task management)

You could build a lightweight MCP server that:

Reads/writes structured planning files from your repo
Exposes functions like get_next_task(), break_down_story(), update_task_status()
Integrates with your event logging (.runs/ directory)
Uses DeepSeek or Claude to generate subtasks autonomously

Example interaction pattern:
powershell# AI agent workflow
$nextTask = Invoke-McpTool -Server planning -Function "get_next_task" -Args @{
  phase = "Phase-1"
  context = "Git safety baseline"
}

# AI generates implementation plan
$detailedPlan = Invoke-McpTool -Server deepseek -Function "generate_implementation" -Args @{
  task = $nextTask
  constraints = $Phase1Policy
}

# Execute with validation
$result = Invoke-McpTool -Server powershell-ai -Function "execute_with_validation" -Args @{
  plan = $detailedPlan
}

# Log to your events system
Write-Event -Status ok -Step "autonomous-task" -Data $result

### 3. **AI-Native Tools to Consider**

**Linear** (Closed-source but excellent AI integration)
- AI-powered issue triage and prioritization
- Natural language → structured issues
- Excellent API for autonomous agents
- Keyboard-first (CLI-friendly mindset)

**Plane** (Open-source Linear alternative)
- Self-hosted
- API-first design (perfect for LLM orchestration)
- YAML import/export
- Could integrate directly with your PowerShell orchestrator

**GitHub Projects + Copilot**
- Already in your stack (you're using `gh`)
- GitHub Copilot can now interact with Projects
- GraphQL API for programmatic access
- Native integration with your `.github/workflows`

### 4. **Autonomous Planning Pattern for Your Stack**

Based on your Phase 0 checklist and bootstrap script, here's a pattern tailored to AI-assisted development:

┌─────────────────────────────────────────────┐
│  Planning Layer (AI-Readable)               │
│  .plans/*.yaml + acceptance criteria        │
└────────────┬────────────────────────────────┘
             │
             ▼
┌─────────────────────────────────────────────┐
│  Orchestration Layer (Your Bootstrap.ps1)   │
│  MCP calls + event logging                  │
└────────────┬────────────────────────────────┘
             │
             ▼
┌─────────────────────────────────────────────┐
│  Execution Layer (Autonomous)               │
│  AI generates code → Pre-commit validates   │
│  → Events logged → Status updates plans     │
└─────────────────────────────────────────────┘

### 5. **Concrete Recommendation for Your Project**

Create a **`.plans/` directory structure** alongside your existing folders:

C:\PowerShell_ deterministi_factory\
├── .plans/
│   ├── schema.json          # JSON Schema for validation
│   ├── epics/
│   │   ├── phase-0-bootstrap.yaml
│   │   ├── phase-1-git-safety.yaml
│   │   └── phase-2-file-hygiene.yaml
│   ├── stories/
│   │   └── (auto-generated by AI from epics)
│   └── tasks/
│       └── (auto-generated, linked to .runs events)
├── scripts/
│   ├── New-PhaseFromTemplate.ps1
│   ├── Get-NextTask.ps1         # AI-powered task selector
│   └── Update-PlanFromEvents.ps1 # Sync events → plan status
AI Agent Workflow:

Morning: AI reads .plans/, your Phase 0 checklist, and recent events
Planning: AI proposes next story breakdown based on completed tasks
Execution: AI generates implementation (via MCP PowerShell AI Shell)
Validation: Your existing gates run (PSScriptAnalyzer, Pester)
Logging: Events flow to .runs/<RUN_ID>/events.jsonl
Update: AI updates .plans/ task statuses based on events

6. Schema-Driven AI Planning
Your Phase 0 checklist is already structured perfectly for AI consumption. Formalize it:
json{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "DeterministicFactoryTask",
  "type": "object",
  "required": ["id", "title", "acceptance_criteria", "ai_hints"],
  "properties": {
    "id": { "type": "string", "pattern": "^(epic|story|task)-\\d{3}(-\\d{3})?$" },
    "ai_hints": {
      "type": "object",
      "properties": {
        "mcp_tools_required": { "type": "array" },
        "reference_docs": { "type": "array" },
        "validation_commands": { "type": "array" },
        "estimated_tokens": { "type": "number" }
      }
    }
  }
}
This lets you use JSON Schema validation (via semgrep or a pre-commit hook) to ensure AI-generated plans stay consistent.