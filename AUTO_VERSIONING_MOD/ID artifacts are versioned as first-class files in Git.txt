the ID artifacts are versioned as first-class files in Git, and the whole thing is built as a **modular, plugin-driven subsystem** so it scales as you add, merge, or retire modules.

Here’s the tight blueprint.

# 1) What are the “ID files”?

Use three layers, each with a clear job:

1. **ID Card (authoritative, per-artifact, committed)**

* Path: `ids/cards/<ULID>.yaml` (and/or `.id/idcard.yaml` next to the doc/module)
* Immutable identity + safe, additive metadata

```yaml
# ids/cards/01JC2P3AZ9TX8Y8ZP9A1M3B7M5.yaml
schema_version: 1
ulid: 01JC2P3AZ9TX8Y8ZP9A1M3B7M5      # never changes
key: MOD_GOAL_NORMALIZER             # human key; stable, non-reused
aliases: [ MOD_GOAL_NORM ]           # additive only
status: active                       # active|deprecated|consolidated
created_at: 2025-11-03T04:20:00Z
retired_at: null
links:
  merged_into: []                    # list of ULIDs
  absorbs: []                        # list of ULIDs
owner: architecture@company
notes: ""
card_version: 1                      # increments when metadata changes (not identity)
```

2. **ID Ledger (append-only, committed)**

* Path: `.ledger/ids.jsonl`
* Event-sourced record of identity changes (CREATE, ADD_ALIAS, DEPRECATE, CONSOLIDATE)
* Each line is a JSON event with its own ULID/timestamp
* Never rewritten; only appended

3. **ID Registry (generated, not hand-edited)**

* Path: `.runs/<RUN_ID>/id-registry.yaml` (CI artifact)
  *or* `ids/registry.yaml` if you prefer committing it
* Built from the ID Cards each run; used for lookups, link checks, guards

> **Versioning rule:** the **ID Card** and **Ledger** are versioned in Git and reviewed like code. The **Registry** is generated (commit optional).

# 2) Are the ID files versioned?

* **Yes.** ID Cards and the ID Ledger live in the repo and are versioned by Git.
* The **ID** itself (the `ulid`) is immutable.
* The **ID Card** has a `card_version` that increments when you add metadata (e.g., new alias, status change). That’s separate from the module/doc’s **SemVer**.
* The **Ledger** is append-only; history is never squashed or force-edited.

# 3) Deterministic keying and growth over time

* Keys (`module_key` / `doc_key`) are generated by a deterministic function (prefix + slug + optional collision suffix). Once merged, **keys are never reused**.
* New modules: mint **ULID**, compute **key**, create **ID Card**, add a **CREATE** event to the Ledger.
* More modules over time: just means more ID Cards; the Registry build scales linearly.
* Cross-repo? Add `scope` fields or bake org/repo into the key generator; identity is still the ULID.

# 4) Deletion, rename, consolidation (no broken history)

* **Deprecate**: flip `status: deprecated` in the ID Card, append `DEPRECATE` to the Ledger, keep the file (or a stub). Never delete the card.
* **Consolidate** (N → 1):

  * New module = new ULID + ID Card.
  * Old modules: set `status: consolidated`, add `merged_into: [<new_ULID>]`.
  * New module adds `absorbs: [<old_ULIDs…>]`.
  * Ledger gets a `CONSOLIDATE` event referencing all ULIDs.
* **Rename**: keep ULID; update `key`; push the old key into `aliases`; Ledger `REKEY` event. No link rot because ULID stays constant.

# 5) CI guards (immutability + uniqueness)

Add these checks (small scripts you likely already have patterns for):

* **Immutability**: if a file under `ids/cards/*.yaml` changes, assert `ulid` unchanged.
* **Uniqueness**: no duplicate `key` across all ID Cards; no duplicate `ulid` files.
* **One-artifact rule** (if you enforce it): PR may touch at most one doc/module plus its ID Card.
* **Post-merge tags** (optional but great): `idcard-{ULID}-v{card_version}` and, for content docs, `docs-{doc_key}-{semver}`.

Tiny immutability snippet (Python), run in PR CI:

```python
# ensure_id_immutability.py
import subprocess, yaml, sys, pathlib
changed = subprocess.check_output(
  ["git","diff","--name-only","origin/main...HEAD","--","ids/cards/*.yaml"]
).decode().split()
for p in changed:
    before = subprocess.check_output(["git","show",f"origin/main:{p}"], stderr=subprocess.DEVNULL)
    after = pathlib.Path(p).read_bytes()
    try:
        b = yaml.safe_load(before) if before else {}
    except Exception:
        b = {}
    a = yaml.safe_load(after)
    if b and a and b.get("ulid") != a.get("ulid"):
        print(f"ULID changed in {p}: {b.get('ulid')} -> {a.get('ulid')}", file=sys.stderr)
        sys.exit(1)
```

# 6) Plugin architecture (modular by design)

Treat identity as a **pluggable subsystem**; each plugin is a small CLI that reads JSON on stdin and writes JSON to stdout. The orchestrator discovers plugins under `plugins/id/*`.

**Plugin contracts (examples)**

* `id.mint`: create ULID + key (deterministic key function), emit an ID Card skeleton
* `id.validate`: validate card/ledger/regulatory rules (immutability, uniqueness)
* `id.registry.build`: build the live registry from cards
* `id.ledger.append`: append events (CREATE, DEPRECATE, CONSOLIDATE, REKEY)
* `id.export.*`: export to CSV/JSON/Markdown for docs
* `id.guard`: PR-level checks (one-artifact rule, alias rules, etc.)

**Plugin manifest (YAML)**

```yaml
# plugins/id/manifest.yaml
api: 1
plugins:
  - name: id.mint
    entry: "python plugins/id/mint.py"
    capabilities: [ mint ]
  - name: id.validate
    entry: "python plugins/id/validate.py"
    capabilities: [ validate, guard ]
  - name: id.registry.build
    entry: "python plugins/id/registry_build.py"
    capabilities: [ registry ]
```

**Why this is modular**

* You can swap the `mint` implementation (e.g., ULID vs UUIDv7) without touching callers.
* You can add enterprise plugins (e.g., `id.export.snowflake`) later.
* All plugins use the same JSON I/O contract, so they compose in CI or local scripts.

# 7) Minimal workflows you’ll wire

* **PR Guard**: run `id.validate` + immutability + uniqueness + one-artifact rule
* **Post-Merge**: run `id.registry.build`; optionally tag `idcard-{ULID}-v{card_version}`
* **Runtime Snapshot**: write `{ ulid→key, key→semver/status }` into the run ledger so every run is tied to the exact identity state

# 8) What this guarantees

* IDs are **structured** (ULID + deterministic human key), **deterministic**, and **audit-safe**.
* The **ID files themselves are versioned** (ID Cards + Ledger in Git).
* The subsystem is **modular + plugin-based**, so you can extend or replace pieces without breaking consumers.
* Deletions, merges, and renames remain **lossless** thanks to tombstones, aliases, and an append-only ledger.


